# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['delegates', 'DatabaseSettings', 'Database', 'DataModel', 'Query']

# %% ../nbs/00_core.ipynb 2
import sqlalchemy
from sqlalchemy import create_engine, URL, Engine
from sqlalchemy.orm import Session
from pydantic import SecretStr
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import Optional,Union
from abc import ABC, abstractproperty,abstractmethod
from contextlib import contextmanager
import inspect
import pandas as pd

# %% ../nbs/00_core.ipynb 5
def delegates(to=None, keep=False):
    "Decorator: replace `**kwargs` in signature with params from `to`"
    def _f(f):
        if to is None: to_f,from_f = f.__base__.__init__,f.__init__
        else:          to_f,from_f = to,f
        sig = inspect.signature(from_f)
        sigd = dict(sig.parameters)
        k = sigd.pop('kwargs')
        s2 = {k:v for k,v in inspect.signature(to_f).parameters.items()
              if v.default != inspect.Parameter.empty and k not in sigd}
        sigd.update(s2)
        if keep: sigd['kwargs'] = k
        from_f.__signature__ = sig.replace(parameters=sigd.values())
        return f
    return _f

# %% ../nbs/00_core.ipynb 8
class DatabaseSettings(BaseSettings):
    drivername:str
    username: Optional[str]=None
    password: Optional[SecretStr]=None
    host: Optional[str]=None
    port: Optional[int]=None
    database: Optional[str]=None
    query: dict[str,str]={}
    


# %% ../nbs/00_core.ipynb 12
class AbstractDatabaseClass(ABC):

    """
    Abstract Base Class for all Database Connections.

    <br><br>
    From [SQLAlchemy docs](https://docs.sqlalchemy.org/en/13/core/engines.html):
    > The Engine is the starting point for any SQLAlchemy application. It’s “home base” for the actual database and its DBAPI.
    > An Engine references both a Dialect and a Pool, which together interpret the DBAPI’s module functions as well as the behavior of the database <br><br>
    > Pool object which will establish a DBAPI connection at localhost:5432 when a connection request is first received
    > - Note that the Engine and its underlying Pool do **not** establish the first actual DBAPI connection until the Engine.connect() method is called, or an operation which is dependent on this method such as Engine.execute() is invoked.
    > - In this way, Engine and Pool can be said to have a lazy initialization behavior.
    >
    > The Engine, once created, can either be used directly to interact with the database, or can be passed to a Session object to work with the ORM.

    """

    def query_to_records(
        self,
        query_string:str,
    ):
        with self._engine.connect() as conn:
            results = [row for row in conn.execute(text(query_string)).mappings()]
        return results

    @delegates(pd.read_sql_query)
    def query_to_df(
        self,
        query_string,
        **kwargs
    ):
        f"""{pd.read_sql_query.__doc__}"""
        with self._engine.connect() as conn:
            df = pd.read_sql_query(query_string,conn,**kwargs)
        return df

    @contextmanager
    def session_scope(self,bind=None,**kwargs):
        """Provide a transactional scope around a series of operations."""

        session = Session(bind=self._engine,**kwargs)
        try:
            yield session
            session.commit()
        except:
            session.rollback()
            raise
        finally:
            session.close()


# %% ../nbs/00_core.ipynb 13
class Database(DatabaseSettings,AbstractDatabaseClass):
    
    _engine:Engine = None
    _engine_url:URL = None

    def __init__(
        self,
        **kwargs
    ):
        # settings __init__
        super().__init__(**kwargs)
        if hasattr(self.password,'get_secret_value'):
            
            password = self.password.get_secret_value()
            print(password)
        else:
            password = self.password
        url = URL.create(
            drivername=self.drivername,
            username=self.username,
            password=password,
            host=self.host,
            port=self.port,
            database=self.database,
            query=self.query
        )
        self._engine_url=url
        self._engine=create_engine(url)

    
    model_config = SettingsConfigDict(
        #allows for attributes of `database settings` to be set as defaults in subclasses without type annotation
        ignored_types=(int,str,dict),
        arbitrary_types_allowed=True
    )
    

# %% ../nbs/00_core.ipynb 23
from pydantic import BaseModel,ConfigDict,Field
from typing import Generic, List, TypeVar

# %% ../nbs/00_core.ipynb 24
DataModelT = TypeVar('DataModelT')

# %% ../nbs/00_core.ipynb 25
class DataModel(BaseModel,Generic[DataModelT]):
    data: List[DataModelT]

    @delegates(BaseModel.model_dump)
    def to_dataframe(self,**kwargs):
        """turns `data` into a DataFrame. Delegates to `pydantic.BaseModel.model_dump` to control model serialization"""
        data = [x.model_dump(**kwargs) for x in self.data]
        return pd.DataFrame(data)

    def _repr_json_(self):
        try:
            return self.model_dump(mode='json')
        except Exception as e:
            logging.warning(e)
            pass

# %% ../nbs/00_core.ipynb 26
class Query(DataModel,Generic[DataModelT]):
    query: str
    data: List[DataModelT] = {}

    def __call__(
        self,
        database: Database,
        query: str = None 
    ):
        # allows optional query overwrite 
        query_to_run = query or getattr(self,'query')
        data = database.query_to_records(query_to_run)
        return self.model_validate(dict(query=query_to_run,data=data))
